<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rose</title>
  <style>
    :root { color-scheme: dark; }
    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
      background: radial-gradient(1200px 800px at 50% 35%, #1a1d24 0%, #0b0d12 55%, #06070a 100%);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    body { display: grid; place-items: center; }

    /* Stage to stack canvases */
    #stage{
      position: relative;
      width: min(92vmin, 780px);
      height: min(92vmin, 780px);
      filter: drop-shadow(0 20px 45px rgba(0,0,0,0.55));
    }
    canvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }

    /* Start screen */
    #startScreen{
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: radial-gradient(1200px 800px at 50% 35%, rgba(26,29,36,0.92) 0%, rgba(11,13,18,0.92) 55%, rgba(6,7,10,0.96) 100%);
      z-index: 50;
    }
    #startBtn{
      appearance: none;
      border: 1px solid rgba(255,255,255,0.16);
      background: linear-gradient(180deg, rgba(255,255,255,0.10), rgba(255,255,255,0.04));
      color: rgba(255,240,246,0.92);
      padding: 14px 24px;
      border-radius: 999px;
      font-size: 18px;
      letter-spacing: .3px;
      cursor: pointer;
      box-shadow: 0 18px 45px rgba(0,0,0,0.55);
      transition: transform .18s ease, border-color .18s ease;
      user-select: none;
    }
    #startBtn:hover{ transform: translateY(-1px); border-color: rgba(255,255,255,0.24); }
    #startBtn:active{ transform: translateY(0px) scale(0.99); }
  </style>
</head>
<body>

<!-- Start screen -->
<div id="startScreen">
  <!-- غيّر الجملة دي براحتك -->
  <button id="startBtn">There’s a surprise ✨</button>
</div>

<!-- Canvases stacked -->
<div id="stage" aria-hidden="true">
  <canvas id="c"></canvas>
  <canvas id="petals"></canvas>
</div>

<script>
/* =======================
   Simple config
======================= */
const DURATION = 60000;          // ms
const CANVAS_SIZE = 680;         // internal resolution (square)
const DPR_MAX = 2;               // cap for performance

/* =======================
   Setup main canvas
======================= */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d", { alpha: true });

/* Petals overlay canvas */
const petalCanvas = document.getElementById("petals");
const pctx = petalCanvas.getContext("2d", { alpha: true });

function resize() {
  const dpr = Math.min(window.devicePixelRatio || 1, DPR_MAX);

  const w = Math.round(CANVAS_SIZE * dpr);
  const h = Math.round(CANVAS_SIZE * dpr);

  canvas.width = w; canvas.height = h;
  petalCanvas.width = w; petalCanvas.height = h;

  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  pctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = "high";
  pctx.imageSmoothingEnabled = true;
  pctx.imageSmoothingQuality = "high";
}
window.addEventListener("resize", resize, { passive: true });
resize();

/* =======================
   Helpers
======================= */
const TAU = Math.PI * 2;

function clamp01(x){ return x<0?0:x>1?1:x; }
function lerp(a,b,t){ return a + (b-a)*t; }
function easeInOutCubic(t){ t=clamp01(t); return t<0.5 ? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2; }
function easeOutCubic(t){ t=clamp01(t); return 1 - Math.pow(1-t, 3); }
function easeOutQuint(t){ t=clamp01(t); return 1 - Math.pow(1-t, 5); }
function easeInOutSine(t){ t=clamp01(t); return -(Math.cos(Math.PI*t)-1)/2; }

function partProgress(ms, start, end, easing = easeInOutCubic) {
  const t = (ms - start) / (end - start);
  return easing(clamp01(t));
}
function alphaFor(ms, start, end, easing = easeInOutCubic) {
  return partProgress(ms, start, end, easing);
}

/* subtle texture */
function makeTexture(size=256) {
  const t = document.createElement("canvas");
  t.width = t.height = size;
  const g = t.getContext("2d");
  g.clearRect(0,0,size,size);

  g.globalAlpha = 0.08;
  g.lineWidth = 1;
  for (let i=0;i<120;i++){
    const y = (i/120)*size;
    g.beginPath();
    g.moveTo(0, y);
    g.lineTo(size, y + 8);
    g.strokeStyle = "rgba(255,255,255,0.22)";
    g.stroke();
  }
  g.globalAlpha = 0.06;
  for (let i=0;i<120;i++){
    const y = (i/120)*size;
    g.beginPath();
    g.moveTo(0, y);
    g.lineTo(size, y - 10);
    g.strokeStyle = "rgba(255,255,255,0.18)";
    g.stroke();
  }

  g.globalAlpha = 0.06;
  for (let i=0;i<900;i++){
    const x = Math.random()*size;
    const y = Math.random()*size;
    const r = Math.random()*1.2;
    g.fillStyle = `rgba(255,255,255,${0.12+Math.random()*0.08})`;
    g.beginPath();
    g.arc(x,y,r,0,TAU);
    g.fill();
  }
  return t;
}
const textureCanvas = makeTexture(256);
const texturePattern = ctx.createPattern(textureCanvas, "repeat");

/* =======================
   Rose layout
======================= */
const W = CANVAS_SIZE;
const H = CANVAS_SIZE;
const center = { x: W*0.5, y: H*0.48 };

const rose = {
  head: { x: center.x, y: center.y - 92, r: 118 },
  stem: {
    top: { x: center.x - 6, y: center.y + 10 },
    mid: { x: center.x + 14, y: center.y + 150 },
    bot: { x: center.x - 8, y: center.y + 292 }
  },
  leaves: [
    { side: -1, anchor: { x: center.x-2, y: center.y + 170 }, scale: 1.06, tilt: -0.25 },
    { side:  1, anchor: { x: center.x+6, y: center.y + 210 }, scale: 0.92, tilt:  0.22 }
  ]
};

/* =======================
   Timeline (total 60s)
======================= */
const TL = {
  guides:   { s:   0, e:  5500 },
  stem:     { s:  4200, e: 13500 },
  leaves:   { s: 11000, e: 21000 },
  outer1:   { s: 19000, e: 26000 },
  outer2:   { s: 24000, e: 31000 },
  outer3:   { s: 29000, e: 36000 },
  inner1:   { s: 34000, e: 42000 },
  inner2:   { s: 39500, e: 48000 },
  inner3:   { s: 46000, e: 54000 },
  finish:   { s: 52000, e: 57500 },
  caption:  { s: 57500, e: 60000 }
};

/* =======================
   Drawing primitives
======================= */
function clear() { ctx.clearRect(0,0,W,H); }

function drawBackgroundAmbient() {
  ctx.save();
  const g = ctx.createRadialGradient(W*0.5, H*0.42, 40, W*0.5, H*0.52, W*0.62);
  g.addColorStop(0.0, "rgba(255,255,255,0.03)");
  g.addColorStop(0.5, "rgba(0,0,0,0.0)");
  g.addColorStop(1.0, "rgba(0,0,0,0.26)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);
  ctx.restore();
}
function drawPaperGrain() {
  ctx.save();
  ctx.globalAlpha = 0.12;
  ctx.fillStyle = texturePattern;
  ctx.fillRect(0,0,W,H);
  ctx.restore();
}

/* Guides */
function drawGuides(p) {
  if (p <= 0) return;
  ctx.save();
  ctx.globalAlpha = 0.38 * p;
  ctx.lineWidth = 1.2;
  ctx.strokeStyle = "rgba(255,255,255,0.18)";
  ctx.setLineDash([6, 8]);

  ctx.beginPath();
  ctx.ellipse(rose.head.x, rose.head.y, rose.head.r*0.98, rose.head.r*0.88, 0, 0, TAU);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(rose.stem.top.x, rose.stem.top.y);
  ctx.bezierCurveTo(
    rose.stem.top.x + 30, rose.stem.top.y + 60,
    rose.stem.mid.x - 36, rose.stem.mid.y + 55,
    rose.stem.bot.x, rose.stem.bot.y
  );
  ctx.stroke();

  ctx.setLineDash([2, 10]);
  ctx.beginPath();
  ctx.moveTo(center.x, center.y - 210);
  ctx.lineTo(center.x, center.y + 330);
  ctx.stroke();

  ctx.restore();
}

/* Dash-stroke helper */
function estimatePathLength(){ return 1000; } // heuristic

function drawPartialStroke(pathFn, t, strokeStyle, lineWidth, shadow, cap="round", join="round") {
  ctx.save();
  ctx.lineCap = cap;
  ctx.lineJoin = join;
  ctx.strokeStyle = strokeStyle;
  ctx.lineWidth = lineWidth;
  if (shadow) {
    ctx.shadowColor = shadow.color;
    ctx.shadowBlur = shadow.blur;
    ctx.shadowOffsetX = shadow.ox || 0;
    ctx.shadowOffsetY = shadow.oy || 0;
  }
  ctx.beginPath();
  pathFn(ctx);
  const len = Math.max(1, estimatePathLength());
  ctx.setLineDash([len * t, len]);
  ctx.lineDashOffset = 0;
  ctx.stroke();
  ctx.restore();
}

/* Stem */
function stemPath(ctx) {
  const s = rose.stem;
  ctx.moveTo(s.top.x, s.top.y);
  ctx.bezierCurveTo(
    s.top.x + 28, s.top.y + 65,
    s.mid.x - 46, s.mid.y + 60,
    s.bot.x, s.bot.y
  );
}
function pointOnStem(t){
  const s = rose.stem;
  const p0 = s.top, p1 = {x:s.top.x+28,y:s.top.y+65}, p2={x:s.mid.x-46,y:s.mid.y+60}, p3=s.bot;
  const u=1-t;
  const x = u*u*u*p0.x + 3*u*u*t*p1.x + 3*u*t*t*p2.x + t*t*t*p3.x;
  const y = u*u*u*p0.y + 3*u*u*t*p1.y + 3*u*t*t*p2.y + t*t*t*p3.y;
  return {x,y};
}
function drawStem(p) {
  if (p <= 0) return;

  ctx.save();
  ctx.lineCap = "round";
  ctx.lineJoin = "round";

  const grd = ctx.createLinearGradient(center.x - 30, center.y + 30, center.x + 40, center.y + 310);
  grd.addColorStop(0.0, "rgba(10, 62, 28, 0.95)");
  grd.addColorStop(0.45,"rgba(22, 104, 44, 0.98)");
  grd.addColorStop(1.0, "rgba(8, 48, 22, 0.96)");

  drawPartialStroke(
    stemPath,
    p,
    "rgba(0,0,0,0.35)",
    16,
    { color: "rgba(0,0,0,0.45)", blur: 18, ox: 0, oy: 10 }
  );

  drawPartialStroke(
    stemPath,
    p,
    grd,
    12.5,
    { color: "rgba(0,0,0,0.35)", blur: 10, ox: 0, oy: 6 }
  );

  const hp = easeOutCubic(p);
  ctx.globalAlpha = 0.9 * hp;
  ctx.lineWidth = 2.2;
  ctx.strokeStyle = "rgba(200,255,220,0.22)";
  ctx.beginPath();
  const s = rose.stem;
  ctx.moveTo(s.top.x + 1.5, s.top.y + 2);
  ctx.bezierCurveTo(
    s.top.x + 20, s.top.y + 70,
    s.mid.x - 22, s.mid.y + 75,
    s.bot.x + 4, s.bot.y - 4
  );
  const len = 1200;
  ctx.setLineDash([len*hp, len]);
  ctx.stroke();

  ctx.globalAlpha = 0.35 * p;
  for (const t of [0.18, 0.33, 0.52, 0.72]) {
    const pt = pointOnStem(t);
    ctx.fillStyle = "rgba(14,70,34,0.9)";
    ctx.beginPath();
    ctx.ellipse(pt.x + (t<0.5?-3:3), pt.y, 2.0, 1.2, (t<0.5?-0.6:0.6), 0, TAU);
    ctx.fill();
    ctx.fillStyle = "rgba(180,255,210,0.10)";
    ctx.beginPath();
    ctx.ellipse(pt.x + (t<0.5?-2:2), pt.y-0.5, 1.2, 0.7, (t<0.5?-0.6:0.6), 0, TAU);
    ctx.fill();
  }

  ctx.restore();
}

/* Leaves */
function leafShapePath(ctx, side=-1, scale=1, tilt=0, anchor={x:0,y:0}) {
  const sx = side;
  ctx.save();
  ctx.translate(anchor.x, anchor.y);
  ctx.rotate(tilt);
  ctx.scale(scale*sx, scale);

  ctx.beginPath();
  ctx.moveTo(0,0);
  ctx.bezierCurveTo(22, -14, 70, -6, 102, 14);
  ctx.bezierCurveTo(72, 42, 36, 52, 0, 42);
  ctx.bezierCurveTo(-10, 30, -8, 14, 0, 0);
  ctx.closePath();

  ctx.restore();
}
function leafMidribPath(ctx, side=-1, scale=1, tilt=0, anchor={x:0,y:0}) {
  const sx = side;
  ctx.save();
  ctx.translate(anchor.x, anchor.y);
  ctx.rotate(tilt);
  ctx.scale(scale*sx, scale);

  ctx.beginPath();
  ctx.moveTo(6, 10);
  ctx.bezierCurveTo(36, 10, 72, 18, 96, 26);

  ctx.restore();
}
function drawLeafVeins(side, scale, tilt, anchor, p) {
  ctx.save();
  ctx.translate(anchor.x, anchor.y);
  ctx.rotate(tilt);
  ctx.scale(scale*side, scale);

  const n = 6;
  for (let i=0;i<n;i++){
    const t = (i+1)/(n+1);
    const y = lerp(14, 36, t);
    const x0 = lerp(16, 26, t);
    const x1 = lerp(54, 92, t);
    ctx.beginPath();
    ctx.moveTo(x0, y);
    ctx.bezierCurveTo(
      lerp(30, 40, t), y-6,
      lerp(60, 70, t), y-2,
      x1, y
    );
    const a = 0.18 * p * (1 - Math.abs(t-0.5)*0.7);
    ctx.globalAlpha = a;
    ctx.stroke();
  }

  ctx.restore();
}
function drawLeaf(p, leaf) {
  if (p <= 0) return;

  const {side, anchor, scale, tilt} = leaf;
  ctx.save();

  ctx.globalAlpha = 0.22 * p;
  ctx.fillStyle = "rgba(0,0,0,0.35)";
  ctx.translate(0, 3);
  leafShapePath(ctx, side, scale, tilt, anchor);
  ctx.fill();
  ctx.translate(0, -3);

  ctx.globalAlpha = 0.98 * p;
  const g = ctx.createLinearGradient(anchor.x-60, anchor.y-40, anchor.x+100, anchor.y+80);
  g.addColorStop(0.0, "rgba(6, 54, 24, 0.98)");
  g.addColorStop(0.45,"rgba(20, 120, 58, 0.98)");
  g.addColorStop(1.0, "rgba(8, 62, 28, 0.98)");

  leafShapePath(ctx, side, scale, tilt, anchor);
  ctx.fillStyle = g;
  ctx.fill();

  ctx.globalAlpha = 0.10 * p;
  ctx.save();
  ctx.clip();
  ctx.fillStyle = texturePattern;
  ctx.translate(30, 10);
  ctx.fillRect(anchor.x-180, anchor.y-180, 360, 360);
  ctx.restore();

  ctx.globalAlpha = 0.20 * p;
  ctx.lineWidth = 1.1;
  ctx.strokeStyle = "rgba(220,255,230,0.12)";
  leafShapePath(ctx, side, scale, tilt, anchor);
  ctx.stroke();

  const mp = easeOutQuint(p);
  ctx.globalAlpha = 0.45 * mp;
  ctx.lineWidth = 2.2;
  ctx.strokeStyle = "rgba(215,255,230,0.22)";
  leafMidribPath(ctx, side, scale, tilt, anchor);
  ctx.save();
  const len = 520;
  ctx.setLineDash([len*mp, len]);
  ctx.stroke();
  ctx.restore();

  ctx.globalAlpha = 0.22 * mp;
  ctx.lineWidth = 1.0;
  ctx.strokeStyle = "rgba(220,255,235,0.10)";
  drawLeafVeins(side, scale, tilt, anchor, mp);

  ctx.globalAlpha = 0.16 * mp;
  ctx.save();
  ctx.translate(anchor.x, anchor.y);
  ctx.rotate(tilt);
  ctx.scale(scale*side, scale);
  ctx.beginPath();
  ctx.moveTo(16, 16);
  ctx.bezierCurveTo(40, 2, 78, 10, 92, 20);
  ctx.bezierCurveTo(70, 30, 44, 34, 20, 30);
  ctx.closePath();
  const hg = ctx.createLinearGradient(30, 0, 80, 42);
  hg.addColorStop(0, "rgba(255,255,255,0.0)");
  hg.addColorStop(0.5,"rgba(255,255,255,0.16)");
  hg.addColorStop(1, "rgba(255,255,255,0.0)");
  ctx.fillStyle = hg;
  ctx.fill();
  ctx.restore();

  ctx.restore();
}

/* Petals (rose drawing) */
function petalGradient(x, y, w, h, deep=1.0) {
  const g = ctx.createLinearGradient(x - w*0.25, y + h*0.35, x + w*0.35, y - h*0.35);
  g.addColorStop(0.0, `rgba(${Math.round(60*deep)}, 8, 18, 0.98)`);
  g.addColorStop(0.35, `rgba(${Math.round(140*deep)}, 18, 44, 0.98)`);
  g.addColorStop(0.70, `rgba(${Math.round(205*deep)}, 78, 118, 0.98)`);
  g.addColorStop(1.0,  "rgba(255, 200, 220, 0.92)");
  return g;
}
function petalShadowGradient(x, y, r) {
  const g = ctx.createRadialGradient(x+12, y+18, 10, x, y, r);
  g.addColorStop(0, "rgba(0,0,0,0.00)");
  g.addColorStop(0.55,"rgba(0,0,0,0.14)");
  g.addColorStop(1, "rgba(0,0,0,0.32)");
  return g;
}
function rimLightGradient(x, y, w, h) {
  const g = ctx.createLinearGradient(x - w*0.2, y - h*0.35, x + w*0.4, y + h*0.2);
  g.addColorStop(0, "rgba(255,255,255,0.0)");
  g.addColorStop(0.5,"rgba(255,230,240,0.22)");
  g.addColorStop(1, "rgba(255,255,255,0.0)");
  return g;
}

function makePetalPath(spec) {
  return function(ctx) {
    const {x,y,rx,ry,rot,curl,skew,asym} = spec;
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(rot);
    ctx.transform(1, 0, skew, 1, 0, 0);

    const a = 0.6 + (asym || 0)*0.3;
    const b = 0.4 + (asym || 0)*0.2;

    ctx.beginPath();
    ctx.moveTo(-rx*0.18, ry*0.46);

    ctx.bezierCurveTo(
      -rx*0.62, ry*0.28,
      -rx*0.78, -ry*0.18,
      -rx*0.22, -ry*0.55
    );

    ctx.bezierCurveTo(
      -rx*0.08, -ry*(0.72 + 0.10*curl),
      rx*(0.20 + 0.10*a), -ry*(0.66 + 0.15*curl),
      rx*(0.38 + 0.08*b), -ry*(0.42 + 0.18*curl)
    );

    ctx.bezierCurveTo(
      rx*(0.78 + 0.03*a), -ry*0.06,
      rx*(0.64 + 0.04*b), ry*(0.34 + 0.02*a),
      rx*0.14, ry*0.50
    );

    ctx.bezierCurveTo(
      rx*0.02, ry*(0.54 + 0.04*curl),
      -rx*0.08, ry*(0.52 + 0.02*curl),
      -rx*0.18, ry*0.46
    );
    ctx.closePath();

    ctx.restore();
  };
}

function paintPetal(ms, start, end, spec, opts={}) {
  const p = partProgress(ms, start, end, easeInOutSine);
  if (p <= 0) return;

  const pathFn = makePetalPath(spec);
  const x = spec.x, y = spec.y;
  const rx = spec.rx, ry = spec.ry;

  const local = clamp01((ms - start) / (end - start));
  const outlineP = easeOutCubic(clamp01(local / 0.28));
  const fillP    = easeInOutCubic(clamp01((local - 0.15) / 0.55));
  const shadeP   = easeInOutCubic(clamp01((local - 0.35) / 0.55));
  const rimP     = easeOutQuint(clamp01((local - 0.52) / 0.45));
  const texP     = easeOutCubic(clamp01((local - 0.58) / 0.42));

  ctx.save();
  ctx.globalAlpha = 0.16 * fillP;
  ctx.fillStyle = "rgba(0,0,0,0.35)";
  ctx.translate(0, 2.5);
  pathFn(ctx);
  ctx.fill();
  ctx.restore();

  ctx.save();
  ctx.globalAlpha = 1.0 * fillP;
  const deep = opts.deep ?? 1.0;
  ctx.fillStyle = petalGradient(x, y, rx*2, ry*2, deep);
  pathFn(ctx);
  ctx.fill();

  ctx.globalAlpha = 0.88 * shadeP;
  ctx.save();
  ctx.clip();
  ctx.fillStyle = petalShadowGradient(x, y, Math.max(rx,ry)*1.25);
  ctx.fillRect(x - rx*1.6, y - ry*1.6, rx*3.2, ry*3.2);
  ctx.restore();

  ctx.globalAlpha = 0.65 * rimP;
  ctx.save();
  ctx.clip();
  ctx.fillStyle = rimLightGradient(x, y, rx*2, ry*2);
  ctx.fillRect(x - rx*1.6, y - ry*1.6, rx*3.2, ry*3.2);
  ctx.restore();

  if (texP > 0) {
    ctx.save();
    ctx.clip();
    ctx.globalAlpha = 0.07 * texP;
    ctx.strokeStyle = "rgba(255,245,250,0.26)";
    ctx.lineWidth = 1.0;
    ctx.lineCap = "round";
    ctx.translate(x, y);
    ctx.rotate(spec.rot);
    ctx.transform(1,0,spec.skew,1,0,0);
    const count = 10;
    for (let i=0;i<count;i++){
      const t = i/(count-1);
      const yy = lerp(-ry*0.22, ry*0.18, t);
      const xx = lerp(-rx*0.28, rx*0.25, t);
      ctx.beginPath();
      ctx.moveTo(xx, yy);
      ctx.bezierCurveTo(xx + rx*0.18, yy - ry*0.06, xx + rx*0.22, yy + ry*0.02, xx + rx*0.36, yy + ry*0.08);
      ctx.stroke();
    }
    ctx.restore();
  }

  ctx.restore();

  ctx.save();
  ctx.globalAlpha = 0.45 * outlineP;
  ctx.lineWidth = opts.outlineWidth ?? 1.6;
  ctx.strokeStyle = "rgba(255,220,235,0.22)";
  pathFn(ctx);
  const len = 900;
  ctx.setLineDash([len*outlineP, len]);
  ctx.stroke();
  ctx.restore();
}

function drawBudLines(p) {
  if (p <= 0) return;
  const x = rose.head.x, y = rose.head.y + 12;
  ctx.save();
  ctx.globalAlpha = 0.22 * p;
  ctx.lineWidth = 1.4;
  ctx.strokeStyle = "rgba(255,220,235,0.16)";
  ctx.lineCap = "round";
  ctx.beginPath();
  ctx.moveTo(x-18, y+22);
  ctx.bezierCurveTo(x-4, y+6, x+8, y-6, x+20, y-24);
  ctx.stroke();

  ctx.globalAlpha = 0.18 * p;
  ctx.lineWidth = 1.2;
  ctx.beginPath();
  ctx.moveTo(x+12, y+26);
  ctx.bezierCurveTo(x+2, y+10, x-4, y-6, x-12, y-22);
  ctx.stroke();
  ctx.restore();
}

function drawFinish(p) {
  if (p <= 0) return;

  ctx.save();
  ctx.globalAlpha = 0.22 * p;
  const gx = rose.head.x, gy = rose.head.y + 18;
  const g = ctx.createRadialGradient(gx, gy+10, 30, gx, gy+20, 200);
  g.addColorStop(0, "rgba(0,0,0,0.0)");
  g.addColorStop(0.55, "rgba(0,0,0,0.12)");
  g.addColorStop(1, "rgba(0,0,0,0.38)");
  ctx.fillStyle = g;
  ctx.fillRect(gx-240, gy-240, 480, 480);
  ctx.restore();

  ctx.save();
  ctx.globalAlpha = 0.28 * p;
  const h = ctx.createRadialGradient(rose.head.x+18, rose.head.y-38, 20, rose.head.x+18, rose.head.y-38, 160);
  h.addColorStop(0, "rgba(255,255,255,0.22)");
  h.addColorStop(0.35,"rgba(255,235,245,0.14)");
  h.addColorStop(1, "rgba(255,255,255,0.0)");
  ctx.fillStyle = h;
  ctx.fillRect(rose.head.x-210, rose.head.y-220, 420, 420);
  ctx.restore();

  ctx.save();
  ctx.globalAlpha = 0.20 * p;
  ctx.lineWidth = 1.0;
  ctx.strokeStyle = "rgba(255,255,255,0.14)";
  ctx.lineCap = "round";
  ctx.beginPath();
  ctx.moveTo(rose.head.x-78, rose.head.y-64);
  ctx.bezierCurveTo(rose.head.x-40, rose.head.y-92, rose.head.x-10, rose.head.y-86, rose.head.x+18, rose.head.y-70);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(rose.head.x+52, rose.head.y-44);
  ctx.bezierCurveTo(rose.head.x+82, rose.head.y-30, rose.head.x+92, rose.head.y-6, rose.head.x+70, rose.head.y+10);
  ctx.stroke();
  ctx.restore();
}

/* Caption */
function drawCaption(p) {
  if (p <= 0) return;
  const x = W * 0.5;
  const y = H * 0.90;

  ctx.save();
  ctx.globalAlpha = 0.95 * p;

  ctx.textAlign = "center";
  ctx.textBaseline = "middle";

  const text = "Fady gives you a rose";

  const grad = ctx.createLinearGradient(x-180, y-12, x+180, y+12);
  grad.addColorStop(0, "rgba(255, 220, 235, 0.0)");
  grad.addColorStop(0.25, "rgba(255, 210, 230, 0.85)");
  grad.addColorStop(0.5, "rgba(255, 245, 250, 0.95)");
  grad.addColorStop(0.75, "rgba(255, 200, 220, 0.85)");
  grad.addColorStop(1, "rgba(255, 220, 235, 0.0)");

  ctx.shadowColor = "rgba(0,0,0,0.55)";
  ctx.shadowBlur = 16;
  ctx.shadowOffsetY = 6;

  ctx.font = "600 34px Georgia, 'Times New Roman', serif";
  ctx.fillStyle = grad;
  ctx.fillText(text, x, y);

  ctx.shadowBlur = 0;
  ctx.globalAlpha = 0.22 * p;
  ctx.lineWidth = 1.0;
  ctx.strokeStyle = "rgba(255, 240, 246, 0.55)";
  ctx.strokeText(text, x, y);

  ctx.restore();
}

/* Petal specs */
function buildPetals() {
  const x = rose.head.x, y = rose.head.y;

  const outer = [
    { x: x-64, y: y+4,  rx: 100, ry: 88, rot: -0.70, curl: 0.30, skew: -0.06, asym: 0.10, deep: 0.95 },
    { x: x+66, y: y+6,  rx: 102, ry: 90, rot:  0.72, curl: 0.33, skew:  0.06, asym: 0.08, deep: 0.96 },
    { x: x+2,  y: y+52, rx: 118, ry: 96, rot:  0.03, curl: 0.22, skew:  0.02, asym: 0.06, deep: 0.92 }
  ];

  const mid = [
    { x: x-30, y: y-18, rx: 86, ry: 72, rot: -0.38, curl: 0.42, skew: -0.03, asym: 0.12, deep: 1.00 },
    { x: x+34, y: y-20, rx: 86, ry: 74, rot:  0.40, curl: 0.44, skew:  0.03, asym: 0.10, deep: 1.00 },
    { x: x+2,  y: y+16, rx: 86, ry: 72, rot:  0.05, curl: 0.40, skew:  0.01, asym: 0.08, deep: 0.98 }
  ];

  const inner = [
    { x: x-14, y: y-46, rx: 62, ry: 54, rot: -0.22, curl: 0.62, skew: -0.02, asym: 0.12, deep: 1.05 },
    { x: x+14, y: y-48, rx: 62, ry: 54, rot:  0.24, curl: 0.64, skew:  0.02, asym: 0.10, deep: 1.05 },
    { x: x+2,  y: y-28, rx: 56, ry: 50, rot:  0.02, curl: 0.70, skew:  0.01, asym: 0.14, deep: 1.08 }
  ];

  return { outer, mid, inner };
}
const petals = buildPetals();

/* =======================
   Falling petals overlay
======================= */
let falling = false;
let fallStart = 0;
let petalParticles = [];

function rand(min,max){ return min + Math.random()*(max-min); }

function spawnPetals(count=34){
  petalParticles = [];
  for(let i=0;i<count;i++){
    petalParticles.push({
      x: rand(-40, W+40),
      y: rand(-H, -20),
      vy: rand(40, 120),         // px/s
      vx: rand(-18, 18),         // px/s
      rot: rand(0, TAU),
      vr: rand(-1.2, 1.2),       // rad/s
      size: rand(10, 22),
      drift: rand(0.6, 1.8),
      phase: rand(0, TAU),
      life: rand(6.5, 10.5)      // seconds
    });
  }
}

function drawOneFallingPetal(x,y,r,size,alpha){
  pctx.save();
  pctx.globalAlpha = alpha;

  pctx.translate(x,y);
  pctx.rotate(r);

  // soft shadow
  pctx.globalAlpha = alpha * 0.18;
  pctx.fillStyle = "rgba(0,0,0,0.9)";
  pctx.beginPath();
  pctx.ellipse(2, 4, size*0.55, size*0.32, 0.4, 0, TAU);
  pctx.fill();

  // petal body gradient
  pctx.globalAlpha = alpha;
  const g = pctx.createLinearGradient(-size, size*0.2, size, -size*0.2);
  g.addColorStop(0, "rgba(140, 18, 44, 0.95)");
  g.addColorStop(0.55, "rgba(220, 82, 132, 0.95)");
  g.addColorStop(1, "rgba(255, 210, 232, 0.92)");
  pctx.fillStyle = g;

  pctx.beginPath();
  pctx.moveTo(-size*0.55, size*0.10);
  pctx.bezierCurveTo(-size*0.75, -size*0.35, -size*0.10, -size*0.85, size*0.35, -size*0.40);
  pctx.bezierCurveTo(size*0.85, 0, size*0.45, size*0.75, -size*0.10, size*0.55);
  pctx.bezierCurveTo(-size*0.35, size*0.45, -size*0.42, size*0.30, -size*0.55, size*0.10);
  pctx.closePath();
  pctx.fill();

  // rim highlight
  pctx.globalAlpha = alpha * 0.30;
  pctx.strokeStyle = "rgba(255,240,246,0.65)";
  pctx.lineWidth = 1;
  pctx.stroke();

  // subtle vein
  pctx.globalAlpha = alpha * 0.16;
  pctx.strokeStyle = "rgba(255,245,250,0.55)";
  pctx.beginPath();
  pctx.moveTo(-size*0.10, -size*0.35);
  pctx.bezierCurveTo(0, -size*0.10, size*0.05, size*0.10, size*0.10, size*0.35);
  pctx.stroke();

  pctx.restore();
}

function updateFalling(now){
  if(!falling) return;

  const dt = Math.min(0.033, (now - fallStart) / 1000); // safe clamp
  fallStart = now;

  pctx.clearRect(0,0,W,H);

  // fade in quickly
  const globalAlpha = 1;

  for(const p of petalParticles){
    p.life -= dt;
    p.y += p.vy * dt;
    p.x += p.vx * dt + Math.sin((now/1000)*p.drift + p.phase) * 14 * dt;
    p.rot += p.vr * dt;

    // recycle if out
    if(p.y > H + 60 || p.life <= 0){
      p.x = rand(-40, W+40);
      p.y = rand(-120, -20);
      p.vy = rand(40, 130);
      p.vx = rand(-20, 20);
      p.rot = rand(0, TAU);
      p.vr = rand(-1.3, 1.3);
      p.size = rand(10, 24);
      p.drift = rand(0.6, 1.8);
      p.phase = rand(0, TAU);
      p.life = rand(6.5, 10.5);
    }

    drawOneFallingPetal(p.x, p.y, p.rot, p.size, globalAlpha);
  }

  requestAnimationFrame(updateFalling);
}

/* =======================
   Render (ONE-SHOT then freeze)
======================= */
let started = false;
let finished = false;
let startTime = 0;

// ensure rose animation uses its own t0 (so button starts from 0ms)
function startShow(){
  if(started) return;
  started = true;

  // hide start screen
  document.getElementById("startScreen").style.display = "none";

  // reset state
  finished = false;
  startTime = performance.now();
  requestAnimationFrame(render);
}

document.getElementById("startBtn").addEventListener("click", startShow);

function render(now) {
  if(!started) return;

  const elapsed = now - startTime;
  const ms = Math.min(elapsed, DURATION); // clamp: no looping

  // draw rose frame
  clear();
  drawBackgroundAmbient();
  drawPaperGrain();

  drawGuides(alphaFor(ms, TL.guides.s, TL.guides.e, easeInOutSine));
  drawStem(alphaFor(ms, TL.stem.s, TL.stem.e, easeInOutCubic));

  {
    const pL = alphaFor(ms, TL.leaves.s, TL.leaves.e, easeInOutCubic);
    const p1 = clamp01(pL*1.05);
    const p2 = clamp01((pL-0.12)/0.88);
    drawLeaf(p1, rose.leaves[0]);
    drawLeaf(p2, rose.leaves[1]);
  }

  paintPetal(ms, TL.outer1.s, TL.outer1.e, petals.outer[0], { deep: petals.outer[0].deep, outlineWidth: 1.7 });
  paintPetal(ms, TL.outer2.s, TL.outer2.e, petals.outer[1], { deep: petals.outer[1].deep, outlineWidth: 1.7 });
  paintPetal(ms, TL.outer3.s, TL.outer3.e, petals.outer[2], { deep: petals.outer[2].deep, outlineWidth: 1.8 });

  paintPetal(ms, TL.inner1.s - 2200, TL.inner1.e - 1400, petals.mid[0], { deep: petals.mid[0].deep, outlineWidth: 1.55 });
  paintPetal(ms, TL.inner1.s - 1700, TL.inner1.e - 900,  petals.mid[1], { deep: petals.mid[1].deep, outlineWidth: 1.55 });
  paintPetal(ms, TL.inner1.s - 1100, TL.inner1.e - 300,  petals.mid[2], { deep: petals.mid[2].deep, outlineWidth: 1.6 });

  paintPetal(ms, TL.inner1.s, TL.inner1.e, petals.inner[0], { deep: petals.inner[0].deep, outlineWidth: 1.45 });
  paintPetal(ms, TL.inner2.s, TL.inner2.e, petals.inner[1], { deep: petals.inner[1].deep, outlineWidth: 1.45 });
  paintPetal(ms, TL.inner3.s, TL.inner3.e, petals.inner[2], { deep: petals.inner[2].deep, outlineWidth: 1.5 });

  {
    const pb = alphaFor(ms, TL.inner2.s - 1200, TL.inner3.e, easeOutCubic);
    drawBudLines(pb);
  }

  drawFinish(alphaFor(ms, TL.finish.s, TL.finish.e, easeInOutCubic));
  drawCaption(alphaFor(ms, TL.caption.s, TL.caption.e, easeOutQuint));

  // stop at the end (freeze final frame)
  if(elapsed >= DURATION){
    if(!finished){
      finished = true;

      // start falling petals once, and keep rose frozen
      falling = true;
      fallStart = performance.now();
      spawnPetals(38);
      requestAnimationFrame(updateFalling);
    }
    return; // no more render() frames -> rose stays ثابتة
  }

  requestAnimationFrame(render);
}
</script>
</body>
</html>
